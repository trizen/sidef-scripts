#!/usr/bin/ruby

# Daniel "Trizen" È˜uteu
# Date: 07 November 2018
# https://github.com/trizen

# A new beautiful formula for computing the partial-sums of the `sigma_k(n)`
# function, for any positive integer `k`, without computing the sigma function.

# Formulas:
#   a(n) = Sum_{j=1..n} sigma_k(j)
#        = Sum_{j=1..n} Sum_{d|j} d^k
#        = Sum_{j=1..n} Sum_{b=1..floor(n/j)} b^k
#        = Sum_{j=1..n} (Bernoulli(k+1, 1+floor(n/k)) - Bernoulli(k+1, 0))/(k+1)
#        = floor((n+1)/2) + Sum_{j=1..floor(n/2)} (Bernoulli(k+1, 1+floor(n/k)) - Bernoulli(k+1, 0))/(k+1)
#
# where Bernoulli(n,x) are the Bernoulli polynomials.

# See also:
#   https://en.wikipedia.org/wiki/Divisor_function
#   https://en.wikipedia.org/wiki/Faulhaber's_formula
#   https://en.wikipedia.org/wiki/Bernoulli_polynomials

func bernoulli_sigma_partial_sum(n, k) {

    var t = bernoulli(k+1)

     floor((n+1)/2) + sum(1..floor(n/2), {|j|
        (bernoulli(k+1, 1+floor(n/j)) - t) / (k+1)
    })
}

func sigma_partial_sum(n, k) {
    sum(1..n, { .sigma(k) })
}

#
## Run some tests
#

for k in (1..10) {

    var n = 1000.irand
    var a = sigma_partial_sum(n, k)
    var b = bernoulli_sigma_partial_sum(n, k)

    assert_eq(a, b)

    say "Sum_{k=1..#{n}} sigma_#{k}(k) = #{b}"
}

__END__
Sum_{k=1..439} sigma_1(k) = 158390
Sum_{k=1..606} sigma_2(k) = 89428845
Sum_{k=1..906} sigma_3(k) = 182745921247
Sum_{k=1..158} sigma_4(k) = 20751543588
Sum_{k=1..591} sigma_5(k) = 7261290636306925
Sum_{k=1..840} sigma_6(k) = 42686645719301011492
Sum_{k=1..333} sigma_7(k) = 19205081250504734854
Sum_{k=1..327} sigma_8(k) = 4825111439384649236832
Sum_{k=1..472} sigma_9(k) = 55519692608089816684245494
Sum_{k=1..432} sigma_10(k) = 9008681557899400667788631360
