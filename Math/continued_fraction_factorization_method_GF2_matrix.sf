#!/usr/bin/ruby

# A simple implementation of the continued fraction factorization method,
# combined with modular arithmetic (variation of the Brillhart-Morrison algorithm).

# Similar to solving the Pell equation:
#   x^2 - d*y^2 = 1, where `d` is known.

# See also:
#   https://en.wikipedia.org/wiki/Pell%27s_equation
#   https://en.wikipedia.org/wiki/Continued_fraction_factorization

# Parts of code inspired by:
#    https://github.com/martani/Quadratic-Sieve

func gauss_elimination(A, n) {

    var m = A.end
    var I = (m+1).of {|i| 1 << i }

    var nrow = -1

    for col in (0 .. min(m, n)) {
        var npivot = -1

        for row in (nrow+1 .. m) {
            if (A[row].bit(col)) {
                npivot = row
                nrow++
                break
            }
        }

        next if (npivot < 0)

        if (npivot != nrow) {
            A.swap(npivot, nrow)
            I.swap(npivot, nrow)
        }

        for row in (nrow+1 .. m) {
            if (A[row].bit(col)) {
                A[row] ^= A[nrow]
                I[row] ^= I[nrow]
            }
        }
    }

    return I
}

func cffmm (n) {

    # Check for primes and negative numbers
    return []  if (n <= 1)
    return [n] if n.is_prime

    # Check for perfect powers
    if (n.is_power) {

        var root  = n.perfect_root
        var power = n.perfect_power

        var factors = __FUNC__(root)

        return (factors * power -> sort)
    }

    # Check for divisibility by 2
    if (n.is_even) {

        var v = n.valuation(2)
        var t = n>>v

        var factors = v.of(2)

        if (t > 1) {
            factors += __FUNC__(t)
        }

        return factors
    }

    var resolve_factor = {|a,b|
        var g = gcd(a - b.isqrt, n)

        if ((g > 1) && (g < n)) {
            return (
                __FUNC__(g) +
                __FUNC__(n/g) -> sort
            )
        }
    }

    var x = n.isqrt
    var y = x
    var z = 1
    var w = x+x
    var r = w

    var (e1, e2) = (1, 0)
    var (f1, f2) = (0, 1)

    var L = 1e3        # maximum number of matrix-rows
    var B = 1e2        # B-smooth limit

    var Q = []
    var A = []
    var S = Hash()

    var pi_B = B.prime_count

    func exponent_signature(factors) {
        var sig = 0

        for p,e in factors {
            sig.setbit!(p.prime_count-1) if e.is_odd
        }

        return sig
    }

    do {
        y = (r*z - y)
        z = ((n - y*y) // z)         #/
        r = ((x + y)   // z)         #/

        var a = ((x*f2 + e2) % n)
        var b = (a*a % n)

        if (S.exists(b)) {
            resolve_factor(a * S{b}, b*b)
            S{b} = a
        }
        else {
            S{b} = a
        }

        if (b.is_square) {
            resolve_factor(a, b)
        }

        var c = (b > w ? n-b : b)
        var b_factors = c.factor_exp

        if (b_factors && (b_factors[-1][0] <= B)) {
            A << exponent_signature(b_factors)
            Q << [a, b]
        }

        (f1, f2) = (f2, (r*f2 + f1) % n)
        (e1, e2) = (e2, (r*e2 + e1) % n)

    } while ((z > 1) && (A.len < L))

    if (A.len < pi_B) {
        A += (pi_B - A.end + 1 -> of(0))
    }

    var I  = gauss_elimination(A, pi_B-1)
    var LR = (A.end - A.rindex_by { !.is_zero })

    for solution in (I.last(LR)) {

        var solution_X = 1
        var solution_Y = 1

        for i in (^Q) {

            if (solution.bit(i)) {

                solution_X *= Q[i][0] %= n      #=
                solution_Y *= Q[i][1] %= n      #=

                if (solution_Y.is_square) {
                    resolve_factor(solution_X, solution_Y)
                }
            }
        }
    }

    return [n]
}

say cffmm(50754640)
say cffmm(4882742467)
say cffmm(25570266803)
say cffmm(2**62 - 1)
say cffmm(2758006706116313);

for k in (2..20) {

    var n = (irand(2, 2**k) * 2.of { random_prime(2**k) }.prod)

    var factors = cffmm(n)
    assert_eq(factors.prod, n)

    if (factors.all { .is_prime }) {
        say "#{n} = #{factors.join(' * ')}"
    }
    else {
        say "#{n} = #{factors.join(' * ')} (incomplete factorization)"
    }
}
