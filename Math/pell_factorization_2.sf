#!/usr/bin/ruby

# Author: Daniel "Trizen" È˜uteu
# Date: 01 March 2018
# https://github.com/trizen

# A new integer factorization method, using continued fractions and square root convergents.

# Similar to solving the Pell equation:
#   x^2 - d*y^2 = 1, where `d` is known.

# Some numbers cannot be factorized using the method.

# Under this method, the following numbers are unfactorizable:
#   2117, 2501, 4223, 5777, 5891, 6319, 6401, 6893, 7339, 7571, 8023, ...

# See also:
#   https://en.wikipedia.org/wiki/Pell%27s_equation

func pell_factorization (n) {

    # Check for primes and negative numbers
    if ((n <= 1) or n.is_prime) {
        return [n]
    }

    # Check for perfect powers
    if (n.is_power) {

        var root  = n.perfect_root
        var power = n.perfect_power

        var factors = __FUNC__(root)

        return (factors * power -> sort)
    }

    # Check for divisibility by 2
    if (n.is_even) {

        var v = n.valuation(2)
        var t = n>>v

        var factors = v.of(2)

        if (t > 1) {
            factors += __FUNC__(t)
        }

        return factors
    }

    var x = n.isqrt
    var y = x
    var z = 1

    var (f1, f2) = (0, 1)

    (f1, f2) = (f2, x*f2 + f1)

    do {

        y = (((x + y)  // z)*z - y)           #/
        z = ((n - y*y) // z)                  #/

        var g = gcd(f2 + y - z, n)

        if ((g > 1) && (g < n)) {
            return (
                __FUNC__(n/g) +
                __FUNC__(g) -> sort
            )
        }

        (f1, f2) = (f2, ((x + y) // z)*f2 + f1) #/

    } while (z > 1)

    # TODO: reduce and generalize
    for t in ([
        f1*f2 + 1,
        f1 - f2 + 1,
        f2*f2 - f1 + 1,
        f2*f2 - f1 - 1,
        f2*f2 - 1,
        f2 + x + 1,
        f2 + x - 1,
        f2*f2 - x + 1,
        f2*f2 + f1,
        f2*f2 - f1,
        f1*f1 - f2 - 1,
        f2 + x*f1 - 1,
        f2 + x*f1 + 1,
        f1 - x*f2 - 1,
        f1 + x*f2 + 1,
        f2 * (f1 - x) - 1,
        f2 * (f1 - x) + 1,
        f2 * (f1 - 2) + 1,
        f2 * (f1 - 2) - 1,
        f1 * (f2 - 4) + 1,
        f1 * (f2 - 4) - 1,
        f1 * (f2 - 15) + 1,
        f1 * (f2 - 20) + 1,
        f1 * (f2 - 64) + 1,
        f1 * (f2 - 82) - 1,
        f2*f2 + (x - f1) + 1,
        f1*f1 - (x - f2) - 1,
        isqrt(4*n * (f2*f2 + 1)) / (2*n),
        #isqrt(4*n * (f1*f1 - 1)) / (2*n),
        #isqrt(4*n * (f1*f1 - 1)) / (2*n) + 1,
        #isqrt(4*n * (f2*f2 + 1)) / (2*n) + 1,
        isqrt(4*n * (f1*f1 + 1)) / (2*n) - f2 + 1,
        isqrt(4*n * (f1*f1 + 1)) / (2*n) + f2 - 1,
        (isqrt(4*n * (f1*f1 + 1)) / (2*n))**2 + f2 - 1,
        (isqrt(4*n * (f1*f1 + 1)) / (2*n))**2 + f2**2 - 1,
        (isqrt(4*n * (f1*f1 + 1)) / (2*n))**2 + f2**2 + 1,
        (isqrt(4*n * (f1*f1 + 1)) / (2*n))**2 - f2**2 + 1,
        (isqrt(4*n * (f1*f1 - 1)) / (2*n))**2 + f2**2,
        (isqrt(4*n * (f1*f1 - 1)) / (2*n)) + f1 + 1,
        (isqrt(4*n * (f1*f1 - 1)) / (2*n))**2 + (isqrt(4*n * (f2*f2 - 1)) / (2*n))**2 - x,
        (isqrt(4*n * (f1*f1 - 1)) / (2*n))**2 - (isqrt(4*n * (f2*f2 - 1)) / (2*n))**2 + x - 1,
        (isqrt(4*n * (f1*f1 - 1)) / (2*n)) - (isqrt(4*n * (f2*f2 - 1)) / (2*n)) + x - 1,
        (isqrt(4*n * (f1*f1 - 1)) / (2*n)) + (isqrt(4*n * (f2*f2 - 1)) / (2*n)) + 1,
        (isqrt(4*n * (f1*f1 + 1)) / (2*n)) - (isqrt(4*n * (f2*f2 + 1)) / (2*n)) + x,
        (isqrt(4*n * (f2*f2 + 1)) / (2*n)) + (isqrt(4*n * (f2*f2 - 1)) / (2*n)) - x + 1,
        (isqrt(4*n * (f1*f1 + 1)) / (2*n))**2 + (isqrt(4*n * (f2*f2 - 1)) / (2*n))**2 - x + 1,
    ]) {
        var g = gcd(t, n)

        if ((g > 1) && (g < n)) {
            return (
                __FUNC__(n/g) +
                __FUNC__(g) -> sort
            )
        }
    }

    return [n]
}

for k in (2..55) {
    var n = (2**k - 1)
    var factors = pell_factorization(n)

    if (factors.all { .is_prime }) {
        say "#{n} = #{factors.join(' * ')}"
    }
    else {
        say "#{n} = #{factors.join(' * ')} (incomplete factorization)"
    }

    assert_eq(factors.prod, n)
}
