#!/usr/bin/ruby

# Author: Daniel "Trizen" È˜uteu
# Date: 01 April 2018
# https://github.com/trizen

# A new integer factorization method, using continued fractions and square root convergents.

# Similar to solving the Pell equation:
#   x^2 - d*y^2 = 1, where `d` is known.

# See also:
#   https://oeis.org/A003285
#   https://en.wikipedia.org/wiki/Pell%27s_equation

func pell_factorization (n) {

    # Check for primes and negative numbers
    if (n <= 1 or n.is_prime) {
        return [n]
    }

    # Check for perfect squares
    if (n.is_square) {
        return (__FUNC__(n.isqrt) * 2 -> sort)
    }

    # Check for divisibility by 2
    if (n.is_even) {

        var v = n.valuation(2)
        var t = n>>v

        var factors = v.of(2)

        if (t > 1) {
            factors += __FUNC__(t)
        }

        return factors
    }

    var x = n.isqrt
    var y = x
    var z = 1

    var r = (x + y)

    var (e1, e2) = (1, 0)
    var (f1, f2) = (0, 1)

    loop {

        y = (r*z - y)
        z = ((n - y*y) / z)
        r = round((x + y)   / z)

        var a = ((x*f2 + e2) % n)
        var b = (a*a % n)

        if (b.is_square) {
            var g = gcd(a - b.isqrt, n)

            if ((g > 1) && (g < n)) {
                return (
                    __FUNC__(g) +
                    __FUNC__(n/g) -> sort
                )
            }
        }

        for t in ([
            e2,
            e2 + f2,
            e2 + f2*x,
            e2 + f2 + f2,
            e2 + e2 + f2 + x,
        ]) {
            var g = gcd(t, n)

            if ((g > 1) && (g < n)) {
                return (
                    __FUNC__(n/g) +
                    __FUNC__(g) -> sort
                )
            }
        }

        (f1, f2) = (f2, (r*f2 + f1) % n)
        (e1, e2) = (e2, (r*e2 + e1) % n)
    }
}

for k in (2..50) {
    var n = irand(2, 1<<k)
    var factors = pell_factorization(n)

    assert_eq(factors.prod, n)
    assert(factors.all { .is_prime })

    say "#{n} = #{factors.join(' * ')}"
}
