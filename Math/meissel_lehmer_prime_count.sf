#!/usr/bin/ruby

# Daniel "Trizen" Șuteu
# 04 September 2025
# https://github.com/trizen

# Basic implementation of the Meissel–Lehmer algorithm for counting the number of primes <= n in sublinear time.

# See also:
#   https://en.wikipedia.org/wiki/Meissel%E2%80%93Lehmer_algorithm

func meissel_lehmer_prime_count(){}

func P2(n, a, p_a) {

    var j = a
    var lo = p_a+1
    var hi = n.isqrt
    var count = 0

    each_prime(lo, hi, {|p|
        count += (meissel_lehmer_prime_count(idiv(n, p)) - j++)
    })

    return count
}

func recursive_rough_count(n,P) {

    func (n,a) is cached {

        if (a == 0) {
            return n
        }

        __FUNC__(n, a-1) - __FUNC__(idiv(n, P[a-1]), a-1)
    }(n, P.len)
}

func meissel_lehmer_prime_count(n) is cached {

    if (n <= 10) {
        return [0, 0, 1, 2, 2, 3, 3, 4, 4, 4, 4][n]
    }

    var P = n.icbrt.inc.primes      # all primes <= n^(1/3)
    var p_a = P[-1]
    var phi = recursive_rough_count(n, P)
    var a = P.len

    phi + a - 1 - P2(n, a, p_a)
}

for n in (1..6) {
    say "pi(10^#{n}) = #{meissel_lehmer_prime_count(10**n)}"
    var x = (10**n -> irand)
    assert_eq(meissel_lehmer_prime_count(x), x.pi)
}

__END__
pi(10^1) = 4
pi(10^2) = 25
pi(10^3) = 168
pi(10^4) = 1229
pi(10^5) = 9592
pi(10^6) = 78498
pi(10^7) = 664579
