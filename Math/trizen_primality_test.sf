#!/usr/bin/ruby

# Daniel "Trizen" È˜uteu
# Date: 01 August 2017
# https://github.com/trizen

# A very high-level implementation of a new primilaty test, inspired from the AKS primality test.

# When n>2 is a (pseudo)prime:
#
#   (2 + sqrt(-1))^n - (sqrt(-1))^n - 2 = 0 (mod n)
#

# By breaking the formula into pieces, we get the following equivalent statements:
#
#   5^(n/2) * cos(n * atan(1/2)) = 2 (mod n)
#   5^(n/2) * sin(n * atan(1/2)) = { n-1   if n=3 (mod 4)
#                                      1   if n=1 (mod 4) } (mod n)
#

# Additionally, we have the following two identities:
#
#   cos(n * atan(1/2)) = (((2+i)/sqrt(5))^n + exp(-1 * log((2+i)/sqrt(5)) * n))/2
#   sin(n * atan(1/2)) = (((2+i)/sqrt(5))^n - exp(-1 * log((2+i)/sqrt(5)) * n))/(2i)
#

# For numbers of the form `2n+1`, the above formulas simplify to:
#
#   cos((2*n + 1) * atan(1/2)) = a(n)/(sqrt(5) * 5^n)
#   sin((2*n + 1) * atan(1/2)) = b(n)/(sqrt(5) * 5^n)
#
# where `a(n)` and `b(n)` are integers given by:
#
#   a(n) = real((2 + sqrt(-1))^n)
#   b(n) = imag((2 + sqrt(-1))^n)
#
# Defined recursively, as:
#
#   a(1) = 2; a(2) = 3; a(n) = 4*a(n-1) - 5*a(n-2)
#   b(1) = 1; b(2) = 4; b(n) = 4*b(n-2) - 5*b(n-2)
#

# For small numbers (< 10^5), the performance of this test is pretty good.
# For larger numbers, more optimizations are needed.

# An obvious optimization would be to compute `a(n)` and `b(n)` modulo `n` directly.

# Known counter-examples (in order):
#   [1105, 2465, 10585, 15841, 29341, 38081, 40501, 41041, 46657, 75361, ...]

func a(n) is cached {       # real((2 + sqrt(-1))^n)
    n == 1 && return 2
    n == 2 && return 3

    4*a(n-1) - 5*a(n-2)
}

func b(n) is cached {       # imag((2 + sqrt(-1))^n)
    n == 1 && return 1
    n == 2 && return 4

    4*b(n-1) - 5*b(n-2)
}

func is_probably_prime(n) {

    var _a_ = (a(n) % n) == 2 || return false
    var _b_ = (b(n) % n)

    (n % 4 == 3) ? (_b_ == n-1) : (_b_ == 1)
}

func is_probably_prime_old(n) {

    define r = 1/2
    local Number!PREC = ceil(log2(5) * (n*r) + 2*log(n))

    #var k = (isqrt(5**n) + r)
    var k = (5**(n >> 1) * sqrt(5))
    var p = (n * atan(r))

    var _a_ = (k * cos(p) -> round % n) == 2 || return false
    var _b_ = (k * sin(p) -> round % n)

    (n % 4 == 3) ? (_b_ == n-1) : (_b_ == 1)
}

each(3..1000, { |n|
    if (is_probably_prime(n)) {

        say n

        if (!n.is_prime) {
            warn "Counter-example: #{n}"
        }
    }
    elsif (n.is_prime) {
        warn "Missed a prime: #{n}"
        Sys.sleep(1)
    }
})
