#!/usr/bin/ruby

# Daniel "Trizen" È˜uteu
# Date: 01 August 2017
# https://github.com/trizen

# A very high-level implementation of a new primilaty test, inspired from the AKS primality test.

# When n>2 is a (pseudo)prime:
#
#   (2 + sqrt(-1))^n - (sqrt(-1))^n - 2 = 0 (mod n)
#

# By breaking the formula into pieces, we get the following equivalent statements:
#
#   5^(n/2) * cos(n * atan(1/2)) = 2 (mod n)
#   5^(n/2) * sin(n * atan(1/2)) = { n-1   if n=3 (mod 4)
#                                      1   if n=1 (mod 4) } (mod n)
#

# Additionally, we have the following two identities:
#
#   cos(n * atan(1/2)) = (((2+i)/sqrt(5))^n + exp(-1 * log((2+i)/sqrt(5)) * n))/2
#   sin(n * atan(1/2)) = (((2+i)/sqrt(5))^n - exp(-1 * log((2+i)/sqrt(5)) * n))/(2i)
#

# For numbers of the form `2n+1`, the above formulas simplify to:
#
#   cos((2*n + 1) * atan(1/2)) = a/(sqrt(5) * 5^n)
#   sin((2*n + 1) * atan(1/2)) = b/(sqrt(5) * 5^n)
#
# where `a` and `b` are integers given by:
#
#   a = real((2 + sqrt(-1))^n)
#   b = imag((2 + sqrt(-1))^n)
#

# For small numbers (< 10^5), the performance of this test is pretty good. For larger numbers, more optimizations are needed.

# Known counter-examples (in order):
#   [1105, 2465, 10585, 15841, 29341, ...]

func is_probably_prime(n) {
    define r = 1/2

    local Number!PREC = ceil(log2(5) * (n*r) + 2*log(n))

    #var k = (isqrt(5**n) + r)

    var k = (5**(n >> 1) * sqrt(5))
    var p = (n * atan(r))

    var _a_ = (k * cos(p) -> round % n) == 2 || return false
    var _b_ = (k * sin(p) -> round % n)

    (n % 4 == 3) ? (_b_ == n-1) : (_b_ == 1)
}

each(3..1000, { |n|
    if (is_probably_prime(n)) {

        say n

        if (!n.is_prime) {
            warn "Counter-example: #{n}"
        }
    }
    elsif (n.is_prime) {
        warn "Missed a prime: #{n}"
        Sys.sleep(1)
    }
})
