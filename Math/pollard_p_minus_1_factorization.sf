#!/usr/bin/ruby

# Simple implementation of Pollard's pâˆ’1 integer factorization algorithm.

# See also:
#   https://en.wikipedia.org/wiki/Pollard%27s_p_%E2%88%92_1_algorithm

func pollard_p1_factor (n) {

    return []  if (n <= 1)
    return [n] if n.is_prime

    if (n.is_even) {
        var v = n.valuation(2)
        return (v.of(2) + pollard_p1_factor(n >> v))
    }

    for (var (t, k, g) = (2, 2) ; true ; k += 16) {

        t = powmod(t, k, n)
        g = gcd(t - 1, n)

        g == 1 && next

        if (g == n) {
            t = k+1
            next
        }

        return (pollard_p1_factor(g) + pollard_p1_factor(n / g) -> sort)
    }
}

say pollard_p1_factor(25889 * 46511)
say pollard_p1_factor(419763345)
say pollard_p1_factor(5040)
say pollard_p1_factor(12129569695640600539)
say pollard_p1_factor(2**42 + 1)
say pollard_p1_factor(2**64 + 1)
say pollard_p1_factor(38568900844635025971879799293495379321)

for n in (2 .. 1000) {
    var factors = pollard_p1_factor(n)

    if (!factors.all { .is_prime }) {
        die "Compositie factor for #{n}"
    }

    if (factors.prod != n) {
        die "Incorrect factors for #{n}"
    }
}
