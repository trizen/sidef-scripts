#!/usr/bin/ruby

# Two equivalent formulas for PI, as iterative numerical procedures.
# However, due to floating-point rounding, the first form, eventually, becomes incorrect.

# See also:
#   https://en.wikipedia.org/wiki/Floating-point_arithmetic

func pi_first_form(n) {
    var t = 1/sqrt(3)
    n.times {
        t = (sqrt(t**2 + 1) - 1)/t
    }
    6 * 2**n * t
}

func pi_second_form(n) {
    var t = 1/sqrt(3)
    n.times {
        t = t/(sqrt(t**2 + 1) + 1)
    }
    6 * 2**n * t
}

for k in (90..95) {
    say [k, pi_first_form(k), pi_second_form(k)]
}

__END__
[90, 3.14159264224489075230253836976644078069734525201, 3.14159265358979323846264338327950288419716939938]
[91, 3.13336295343687286020067674353743084477864440181, 3.14159265358979323846264338327950288419716939938]
[92, 3.14159264224489075230253836976644078069734525201, 3.14159265358979323846264338327950288419716939938]
[93, 3.04383829762439077848065740800778996349925456175, 3.14159265358979323846264338327950288419716939938]
[94, 2.95679307505401482569650670095665014653867788425, 3.14159265358979323846264338327950288419716939938]
[95, 3.04383829762439077848065740800778996349925456175, 3.14159265358979323846264338327950288419716939938]
