#!/usr/bin/ruby

# Daniel "Trizen" Șuteu
# Date: 27 November 2018
# https://github.com/trizen

# A nice algorithm in terms of the prime-counting function for computing partial sums of the bigomega(n) function:
#   a(n) = Sum_{k=1..n} Ω(k)

# Also equivalent with:
#   a(n) = bigomega(n!)

# See also:
#   https://oeis.org/A025528
#   https://oeis.org/A022559
#   https://oeis.org/A071811
#   https://en.wikipedia.org/wiki/Prime_omega_function
#   https://en.wikipedia.org/wiki/Prime-counting_function
#   https://trizenx.blogspot.com/2018/11/partial-sums-of-arithmetical-functions.html

# Example:
#    a(10^1) = 15
#    a(10^2) = 239
#    a(10^3) = 2877
#    a(10^4) = 31985
#    a(10^5) = 343614
#    a(10^6) = 3626619
#    a(10^7) = 37861249
#    a(10^8) = 392351272

func prime_power_count(n) {
    sum(1..n.ilog2, {|k|
        prime_count(n.iroot(k))
    })
}

func prime_bigomega_partial_sum(n) {

    var s = n.isqrt
    var u = floor(n/(s+1))

    var total = 0

    for k in (1..s) {
        total += k*(prime_power_count(floor(n/k)) - prime_power_count(floor(n/(k+1))))
    }

    for k in (1..u) {
        total += floor(n/k) if k.is_prime_power
    }

    return total
}

for n in (1..6) {
    say "a(10^#{n}) = #{prime_bigomega_partial_sum(10**n)}"
}
