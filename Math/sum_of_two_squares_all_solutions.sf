#!/usr/bin/ruby

# Daniel "Trizen" Șuteu
# Date: 22 November 2025
# https://github.com/trizen

# A fast algorithm for finding all the non-negative integer solutions to the equation:
#   a^2 + b^2 = n
# for any given positive integer `n` for which such a solution exists.

# Example:
#   99025 = 41^2 + 312^2 = 48^2 + 311^2 = 95^2 + 300^2 = 104^2 + 297^2 = 183^2 + 256^2 = 220^2 + 225^2

# Blog post:
#   https://trizenx.blogspot.com/2017/10/representing-integers-as-sum-of-two.html

# This algorithm is efficient when the factorization of `n` can be computed.

# See also:
#   https://oeis.org/A001481

# Find a solution to x^2 + y^2 = p, for prime numbers `p` congruent to 1 mod 4.
func primitive_sum_of_two_squares (p) {

    if (p == 2) {
        return (1, 1)
    }

    var s = sqrtmod(-1, p) || die "error"
    var q = p

    while (s*s > p) {
        (s, q) = (q % s, s)
    }

    return (s, q % s)
}

# Multiply two representations (a,b) and (c,d),
# return all distinct sign/ordering variations.
func combine_pairs(A, B, C, D) {
    return [
            [A*C - B*D, A*D + B*C],
            [A*C + B*D, A*D - B*C],
            [B*C - A*D, A*C + B*D],
            [B*C + A*D, A*C - B*D],
           ]
}

# Multiply two *sets* of representations
func multiply_sets(A, B) {
    var seen = Hash()
    var new = []
    for p in (A), q in (B) {
        for x,y in (combine_pairs(p..., q...)) {
            if (x > y) {
                (x, y) = (y, x)
            }
            var key = "#{x},#{y}"
            if (seen.has(key)) {
                next
            }
            else {
                seen{key} = true
            }
            new << [x,y]
        }
    }
    return new
}

func sum_of_two_squares_solutions(n) {

    n < 0  && return []
    n == 0 && return [[0, 0]]

    var factors = n.factor_exp

    # Start with representation of 1
    var reps = [[0, 1]]    # (0^2 + 1^2 = 1)

    for p,k in (factors) {

        # Handle primes 3 mod 4
        if (p % 4 == 3) {
            if (k % 2 != 0) {
                return []    # no solutions
            }

            # p^{2t} contributes factor (p^t)^2 which is a square; doesn't change reps aside from scaling
            # We'll multiply later by p^{k/2} as a scaling factor on both coordinates.
            # For simplicity, handle by multiplying reps by p^{k/2} at the end.
            next
        }

        # Representation of p = a^2 + b^2
        var (a, b) = primitive_sum_of_two_squares(p)

        # Use binary exponentiation to get representations for p^k
        var acc   = [[0, 1]]
        var base  = [[a,b]]
        var exp_k = k
        while (exp_k > 0) {
            if (exp_k & 1) {
                acc = multiply_sets(acc, base)
            }
            base = multiply_sets(base, base)
            exp_k >>= 1
        }
        reps = multiply_sets(reps, acc).grep { (_[0] >= 0) && (_[1] >= 0) }
    }

    # Handle primes p ≡ 3 (mod 4) with even exponent: they contribute as a perfect square factor s^2.
    # Multiply each (x,y) by s where s = product p^{e/2} over such primes.
    var square_scale = 1
    for p,e in (factors) {

        if (p % 4 != 3) {
            next
        }

        square_scale *= p**(e >> 1)
    }

    if (square_scale != 1) {
        reps = reps.map { [_[0] * square_scale, _[1] * square_scale] }
    }

    # Sort final reps
    reps = reps.map{.sort}.sort

    return reps
}

50.times {
    var n = 1e30.irand
    var solutions = sum_of_two_squares_solutions(n) || next
    assert_eq(solutions, n.sum_of_squares)
    say %Q(#{n} = #{solutions.map {|a| "#{a[0]}^2 + #{a[1]}^2" }.join(' = ') })
}

assert_eq(sum_of_two_squares_solutions(2025), [[0, 45], [27, 36]])
assert_eq(sum_of_two_squares_solutions(164025), [[0, 405], [243, 324]])
assert_eq(sum_of_two_squares_solutions(99025), [[41, 312], [48, 311], [95, 300], [104, 297], [183, 256], [220, 225]])

assert_eq(
    -10 .. 160 -> grep { sum_of_two_squares_solutions(_).len > 0 },
    %n[0, 1, 2, 4, 5, 8, 9, 10, 13, 16, 17, 18, 20, 25, 26, 29, 32, 34, 36, 37, 40, 41, 45, 49, 50, 52, 53, 58, 61, 64, 65, 68, 72, 73, 74, 80, 81, 82, 85, 89, 90, 97, 98, 100, 101, 104, 106, 109, 113, 116, 117, 121, 122, 125, 128, 130, 136, 137, 144, 145, 146, 148, 149, 153, 157, 160]
)

assert_eq(
    sum_of_two_squares_solutions(11392163240756069707031250),
    [[39309472125, 3374998963875], [216763660575, 3368260197225], [477329304375, 3341305130625], [729359177085, 3295481517405], [735019741071, 3294223614297], [907262616645, 3251005657515], [982736803125, 3228992353125], [1151205969375, 3172835964375], [1224793301193, 3145162095999], [1393801568775, 3074000720175], [1622919634875, 2959441687125], [1847545189875, 2824666354125], [1993551800625, 2723584854375], [2056446956025, 2676413487825], [2194367046795, 2564549961435], [2198769707673, 2560776252111], [2386646521875, 2386646521875]]
)
