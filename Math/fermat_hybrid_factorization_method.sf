#!/usr/bin/ruby

# Daniel "Trizen" È˜uteu
# Date: 27 February 2018
# https://github.com/trizen

# A hybrid factorization algorithm, based on Pollard's p-1 and Pollard's rho algorithms and Fermat's factorization method.

# See also:
#   https://en.wikipedia.org/wiki/Quadratic_sieve
#   https://en.wikipedia.org/wiki/Dixon%27s_factorization_method
#   https://en.wikipedia.org/wiki/Fermat%27s_factorization_method
#   https://en.wikipedia.org/wiki/Pollard%27s_p_%E2%88%92_1_algorithm

func fermat_hybrid_factorization (n) {

    if ((n <= 1) or n.is_prime) {
        return [n]
    }

    if (n.is_even) {

        var v = n.valuation(2)
        var t = n>>v

        var factors = v.of(2)

        if (t > 1) {
            factors += __FUNC__(t)
        }

        return factors
    }

    var p = n.isqrt
    var q = (p*p - n)

    var u = 1
    var v = 1

    var z = 2
    var k = 2

    var g = 1
    var c = q+p

    var a0 = 1
    var a1 = (a0*a0 + c)
    var a2 = (a1*a1 + c)

    while (!q.is_square) {

        # Trizen's factorization method
        u = powmod(q * u, k, n)
        v = powmod(p * v, k, n)

        g = gcd(u - v, n)

        if ((g > 1) && (g < n)) {
            return (
                __FUNC__(n/g) +
                __FUNC__(g) -> sort
            )
        }

        q += ((p++ << 1) + 1)

        # Pollard's rho algorithm
        g = gcd(n, a2-a1)

        if ((g > 1) && (g < n)) {
            return (
                __FUNC__(n/g) +
                __FUNC__(g) -> sort
            )
        }

        a1 = ((a1*a1 + c) % n)
        a2 = ((a2*a2 + c) % n)
        a2 = ((a2*a2 + c) % n)

        # Pollard's p-1 algorithm
        z = powmod(z, k, n)
        g = gcd(z - 1, n)

        k += 16

        if (g > 1) {

            if (g == n) {
                z = k+1
                next
            }

            return (
                __FUNC__(n/g) +
                __FUNC__(g) -> sort
            )
        }
    }

    # Fermat's method
    var s = q.isqrt

    __FUNC__(p + s) +
    __FUNC__(p - s) -> sort
}

var tests = [
    160587846247027, 5040, 65127835124, 6469693230,
    12129569695640600539, 2**42 + 1, 2**64 + 1,
    38568900844635025971879799293495379321,
]

for n in (tests) {
    var prime_factors = fermat_hybrid_factorization(n)
    say "#{prime_factors.join(' * ')} = #{n}"
    assert_eq(prime_factors.prod, n)
}

for n in (2..10000) {
    var factors = fermat_hybrid_factorization(n)
    assert(factors.all { .is_prime })
    assert_eq(factors.prod, n)
}
