#!/usr/bin/ruby

# Encode and decode small files using LZ77 compression + Huffman encoding.

define(
    CHUNK_SIZE = (1 << 16),
    SIGNATURE  = ('LZ77H' + 1.chr)
)

func walk(Hash n, String s, Hash h) {
    if (n.has(:a)) {
        h{n{:a}} = s
        return nil
    }
    walk(n{:0}, s+'0', h)
    walk(n{:1}, s+'1', h)
}

func make_tree(Array bytes) {

    var nodes = bytes.freq.kv.sort.map_2d { |b,f|
        Hash(a => b, freq => f)
    }

    var n = Hash()
    while (nodes.sort_by!{|h| h{:freq} }.len > 1) {
        n = Hash(:0 => nodes.shift, :1 => nodes.shift)
        n{:freq} = (n{:0}{:freq} + n{:1}{:freq})
        nodes << n
    }

    walk(n, '', n{:tree} = Hash())
    return n
}

func huffman_encode(Array bytes, Hash t) {
    bytes.map { t{_} }.join
}

func huffman_decode (String bits, Hash tree) {
    bits.gsub(Regex('(' + tree.keys.sort_by { .len }.join('|') + ')'), {|s| tree{s} })
}

func create_huffman_entry (Array bytes, FileHandle out_fh) {

    var h   = make_tree(bytes){:tree}
    var enc = huffman_encode(bytes, h)

    var dict  = ''
    var codes = ''

    for i in (0..255) {
        var c = (h{i} \\ '')
        codes += c
        dict  += c.len.chr
    }

    out_fh.print(dict)
    out_fh.print(pack("B*", codes))
    out_fh.print(pack("N",  enc.len))
    out_fh.print(pack("B*", enc))
}

func lz77_compress (String str) {

    var la = 0
    var rep = []

    var prefix = ''
    var chars  = str.chars
    var end    = chars.end

    while (la <= end) {

        var n = 1
        var p = 0

        var token = chars[la]

        while ((n < 255) && (la+n <= end) && ((var tmp = prefix.index(token, p)) >= 0)) {
            p = tmp
            token += chars[la + n]
            ++n
        }

        --n
        rep << [p, n, chars[la + n]]
        la += n+1
        prefix += token
    }

    return rep
}

# Compress file
func lz77h_compress_file(File input, File output) {

    var in_fh  =  input.open('<:raw') || die "Can't open file <<#{input}>> for reading"
    var out_fh = output.open('>:raw') || die "Can't open file <<#{output}>> for writing"

    var header = SIGNATURE

    # Print the header
    out_fh.print(header)

    var uncompressed = []
    var lengths = []
    var indices = []

    # Compress data
    while (in_fh.read(\var chunk, CHUNK_SIZE)) {
        var compressed_data = lz77_compress(chunk)
        for i,l,c in (compressed_data) {
            indices      << i
            lengths      << l
            uncompressed << c
        }
    }

    uncompressed = [unpack('C*', uncompressed.join)]
    indices      = [unpack('C*', pack('S*', indices...))]

    create_huffman_entry(uncompressed, out_fh)
    create_huffman_entry(indices,      out_fh)
    create_huffman_entry(lengths,      out_fh)

    # Close the files
    in_fh.close
    out_fh.close
}

func decode_huffman_entry (FileHandle fh) {

    var codes = []
    var codes_len = 0

    for c in (0..255) {
        var l = fh.getc.ord
        if (l > 0) {
            codes_len += l
            codes << [c, l]
        }
    }

    var codes_bin = ''
    while (codes_bin.len < codes_len) {
        codes_bin += unpack('B*', fh.getc \\ break)
    }

    var rev_dict = Hash()
    for c,l in (codes) {
        var code = substr(codes_bin, 0, l)
        codes_bin.substr!(l)
        rev_dict{code} = c.chr
    }

    var enc_len = unpack('N', 4.of{ fh.getc }.join)

    if (enc_len > 0) {

        var enc_data = ''
        while (enc_data.len < enc_len) {
            enc_data += unpack('B*', fh.getc)
        }

        if (enc_data.len > enc_len) {
            enc_data.substr!(0, enc_len)
        }

        return huffman_decode(enc_data, rev_dict)
    }

    return ''
}

# Decompress file
func lz77h_decompress_file(File input, File output) {

    var in_fh = input.open('<:raw') || die "Can't open file <<#{input}>> for reading"

    if (SIGNATURE.len.of { in_fh.getc }.join != SIGNATURE) {
        die "Not a LZ77H archive!\n"
    }

    var out_fh = output.open('>:raw') || die "Can't open file <<#{output}>> for writing"

    var uncompressed = decode_huffman_entry(in_fh).chars
    var indices      = [unpack('S*', decode_huffman_entry(in_fh))]
    var lengths      = [unpack('C*', decode_huffman_entry(in_fh))]

    var chunk = ''
    [uncompressed, indices, lengths].zip {|c,i,l|

        chunk += (chunk.substr(i, l) + c)

        if (chunk.len >= CHUNK_SIZE) {
            out_fh.print(chunk)
            chunk = ''
        }
    }

    out_fh.print(chunk)

    in_fh.close
    out_fh.close
}

ARGV.getopt!('d', \var decode)

var file = File(ARGV.shift) || do {
    say "usage: #{File(__MAIN__).basename} [-d] [input file]"
    Sys.exit(2)
}

if (decode || file.match(/\.lz77h\.enc\z/)) {
    lz77h_decompress_file(file, File("output.lz77h.dec"))
}
else {
    lz77h_compress_file(file, File("output.lz77h.enc"))
}
